根据题目描述，可知该问题本质是「区间求最值」问题（RMQ）。

而求解 RMQ 有多种方式：递归分治、有序集合/ST/线段树 和 单调栈。


递归分治
设置递归函数 TreeNode build(int[] nums, int l, int r) 含义为从 nums 中的 [l,r][l, r][l,r] 下标范围进行构建，返回构建后的头结点。

当 l>rl > rl>r 时，返回空节点，否则在 [l,r][l, r][l,r] 中进行扫描，找到最大值对应的下标 idx 并创建对应的头结点，递归构建 [l,idx−1][l, idx - 1][l,idx−1] 和 [idx+1,r][idx + 1, r][idx+1,r] 作为头节点的左右子树。


线段树
抽象成区间求和问题后，涉及「单点修改」和「区间查询」，再结合节点数量为 1e31e31e3，可使用 build 4n4n4n 空间不带懒标记的线段树进行求解。

设计线段树节点 Node 包含属性：左节点下标 l、右节点下标 r 和当前区间 [l,r][l, r][l,r] 所对应的最值 valvalval。

构建线段树的过程为基本的线段树模板内容，而构建答案树的过程与递归分治过程类型（将线性找最值过程用线段树优化）。


单调栈
更进一步，根据题目对树的构建的描述可知，nums 中的任二节点所在构建树的水平截面上的位置仅由下标大小决定。

不难想到可抽象为找最近元素问题，可使用单调栈求解。

具体的，我们可以从前往后处理所有的 nums[i]nums[i]nums[i]，若存在栈顶元素并且栈顶元素的值比当前值要小，根据我们从前往后处理的逻辑，可确定栈顶元素可作为当前 nums[i]nums[i]nums[i] 对应节点的左节点，同时为了确保最终 nums[i]nums[i]nums[i] 的左节点为 [0,i−1][0, i - 1][0,i−1] 范围的最大值，我们需要确保在构建 nums[i]nums[i]nums[i] 节点与其左节点的关系时，[0,i−1][0, i - 1][0,i−1] 中的最大值最后出队，此时可知容器栈具有「单调递减」特性。基于此，我们可以分析出，当处理完 nums[i]nums[i]nums[i] 节点与其左节点关系后，可明确 nums[i]nums[i]nums[i] 可作为未出栈的栈顶元素的右节点。

一些细节：Java 容易使用 ArrayDeque 充当容器，但为与 TS 保存一致，两者均使用数组充当容器。
